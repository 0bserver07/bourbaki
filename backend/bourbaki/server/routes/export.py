"""POST /export — Export proofs as LaTeX, Lean, or Markdown documents."""

from __future__ import annotations

import re
from datetime import datetime, timezone
from typing import Any

from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter(prefix="/export", tags=["export"])


class ExportRequest(BaseModel):
    """Request to export a proof."""

    title: str = "Untitled Proof"
    statement: str = ""
    proof: str = ""
    lean_code: str | None = None
    sympy_computations: list[dict[str, Any]] | None = None
    format: str = "latex"  # "latex", "lean", "markdown"


class ExportResponse(BaseModel):
    """Exported document."""

    format: str
    filename: str
    content: str


# ---------------------------------------------------------------------------
# LaTeX export
# ---------------------------------------------------------------------------

LATEX_TEMPLATE = r"""\documentclass[12pt]{{amsart}}
\usepackage{{amsmath,amssymb,amsthm,mathtools}}
\usepackage[margin=1in]{{geometry}}

\theoremstyle{{plain}}
\newtheorem{{theorem}}{{Theorem}}
\newtheorem{{lemma}}[theorem]{{Lemma}}
\newtheorem{{proposition}}[theorem]{{Proposition}}
\newtheorem{{corollary}}[theorem]{{Corollary}}
\theoremstyle{{definition}}
\newtheorem{{definition}}[theorem]{{Definition}}
\theoremstyle{{remark}}
\newtheorem*{{remark}}{{Remark}}

\title{{{title}}}
\author{{Bourbaki Agent}}
\date{{{date}}}

\begin{{document}}
\maketitle

\begin{{theorem}}
{statement}
\end{{theorem}}

\begin{{proof}}
{proof}
\end{{proof}}
{lean_section}
{computation_section}
\end{{document}}
"""


def _latex_escape(text: str) -> str:
    """Minimal LaTeX escaping for prose text (not math)."""
    # Don't escape $ or \ — they're likely intentional LaTeX
    text = text.replace("&", r"\&")
    text = text.replace("%", r"\%")
    text = text.replace("#", r"\#")
    text = text.replace("_", r"\_")
    return text


def _build_latex(req: ExportRequest) -> str:
    lean_section = ""
    if req.lean_code:
        lean_section = (
            "\n\\section*{Lean 4 Formalization}\n"
            "\\begin{verbatim}\n"
            f"{req.lean_code}\n"
            "\\end{verbatim}\n"
        )

    computation_section = ""
    if req.sympy_computations:
        lines = ["\\section*{Symbolic Computations}\n\\begin{align*}"]
        for comp in req.sympy_computations:
            latex_str = comp.get("latex", comp.get("result", ""))
            op = comp.get("operation", "")
            if latex_str:
                lines.append(f"  \\text{{{op}:}} \\quad & {latex_str} \\\\")
        lines.append("\\end{align*}")
        computation_section = "\n".join(lines)

    date = datetime.now(tz=timezone.utc).strftime("%B %d, %Y")

    return LATEX_TEMPLATE.format(
        title=req.title,
        date=date,
        statement=req.statement,
        proof=req.proof,
        lean_section=lean_section,
        computation_section=computation_section,
    )


# ---------------------------------------------------------------------------
# Lean export
# ---------------------------------------------------------------------------

def _build_lean(req: ExportRequest) -> str:
    lines = [
        "/-!",
        f"# {req.title}",
        "",
        f"Generated by Bourbaki on {datetime.now(tz=timezone.utc).strftime('%Y-%m-%d')}",
        "",
    ]
    if req.statement:
        lines.append(f"Statement: {req.statement}")
    lines.append("-/")
    lines.append("")

    if req.lean_code:
        lines.append(req.lean_code)
    else:
        # Generate a skeleton from the statement
        safe_name = re.sub(r"[^a-zA-Z0-9_]", "_", req.title.lower())[:40]
        lines.extend([
            "import Mathlib",
            "import Mathlib.Tactic",
            "",
            f"-- TODO: Formalize the proof",
            f"theorem {safe_name} : sorry := by",
            "  sorry",
        ])

    lines.append("")
    return "\n".join(lines)


# ---------------------------------------------------------------------------
# Markdown export
# ---------------------------------------------------------------------------

def _build_markdown(req: ExportRequest) -> str:
    lines = [
        f"# {req.title}",
        "",
        f"*Generated by Bourbaki — {datetime.now(tz=timezone.utc).strftime('%Y-%m-%d')}*",
        "",
        "## Statement",
        "",
        req.statement or "*No statement provided.*",
        "",
        "## Proof",
        "",
        req.proof or "*No proof provided.*",
        "",
    ]

    if req.lean_code:
        lines.extend([
            "## Lean 4 Formalization",
            "",
            "```lean",
            req.lean_code,
            "```",
            "",
        ])

    if req.sympy_computations:
        lines.extend(["## Symbolic Computations", ""])
        for comp in req.sympy_computations:
            op = comp.get("operation", "?")
            result = comp.get("result", comp.get("latex", ""))
            lines.append(f"- **{op}**: `{result}`")
        lines.append("")

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# Route
# ---------------------------------------------------------------------------

EXTENSIONS = {"latex": ".tex", "lean": ".lean", "markdown": ".md"}
BUILDERS = {"latex": _build_latex, "lean": _build_lean, "markdown": _build_markdown}


@router.post("")
async def export_proof(req: ExportRequest) -> ExportResponse:
    fmt = req.format.lower()
    if fmt not in BUILDERS:
        fmt = "latex"

    builder = BUILDERS[fmt]
    content = builder(req)

    safe_title = re.sub(r"[^a-zA-Z0-9_-]", "_", req.title.lower())[:50]
    filename = f"{safe_title}{EXTENSIONS[fmt]}"

    return ExportResponse(format=fmt, filename=filename, content=content)
